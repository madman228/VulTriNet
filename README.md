# VulTriNet: A Software Vulnerability Detection Method Based on Tri-channel Network
A new vulnerability detection approachï¼ŒThe code implementation is mainly based on VulCNN: https://github.com/CGCL-codes/VulCNN, you can refer to it for basic implementation (especially PDG).

Software vulnerabilities represent a critical concern in the domain of cybersecurity. As vulnerability patterns become increasingly complex, the security community requires advanced detection methods to comprehensively analyze vulnerability characteristics. In recent years, some researchers take source codes as text using natural language processing (NLP) techniques. Subsequent advancements transformed programs into intermediate representations, such as program dependency graph (PDG), utilizing graph neural network (GNN) for vulnerability pattern learning. Due to the impressive performance of both approaches, we developed a hybrid analysis model that strengthens vulnerability detection capabilities by simultaneously maintaining contextual code understanding and structural relationship awareness. We proposed a novel vulnerability detection method based on a tri-channel network (VulTriNet). It integrates two graph-based and one textual code representation using three distinct methods to transform functions into multiple forms. Then, VulTriNet generates corresponding embedding vectors for these transformed representations, which are merged into a three-channel feature matrix. Finally, we design a CNN model integrated with attention mechanisms to improve the capability of detecting vulnerabilities. We applied VulTriNet and conducted experiments on multiple vulnerability datasets.

# Design of the Approach
![overview_twolayers](https://github.com/user-attachments/assets/0ecd737d-da38-4bd5-9d18-162f341e1146)
This section presents **VulTriNet**, an efficient and novel model for source code vulnerability detection. As shown in Figure, VulTriNet consists of three steps: function transformation, embedding vector generation, and classification. In **Step 1**, the function transformation explains how the function is transformed. Here, the code is cleaned up to produce a text representation, which is then further normalized to generate the function's AST and PDG. In **Step 2**, embedding vector generation converts the function's representation into a vector. For the function's AST, we apply depth-first traversal (DFT) and use Word2Vec to generate the vector representation. The PDG is embedded using Sent2Vec, while the code text is processed through the CodeBERT model. In **Step 3**, we input the generated tri-channel image into the CNN for classification. The classification performs binary classification to determine whether the function contains any vulnerabilities.
